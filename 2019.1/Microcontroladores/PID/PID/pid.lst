CCS PCM C Compiler, Version 5.081, 13314               17-jun-19 10:00

               Filename:   C:\Users\pedro\OneDrive\Faculdade\Faculdade\2019.1\Microcontroladores\PID\PID\pid.lst

               ROM used:   2103 words (26%)
                           Largest free fragment is 2048
               RAM used:   74 (20%) at main() level
                           92 (25%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   04C
002B:  MOVF   22,W
002C:  MOVWF  04
002D:  MOVF   23,W
002E:  MOVWF  77
002F:  MOVF   24,W
0030:  MOVWF  78
0031:  MOVF   25,W
0032:  MOVWF  79
0033:  MOVF   26,W
0034:  MOVWF  7A
0035:  MOVF   27,W
0036:  BSF    03.6
0037:  MOVWF  0D
0038:  BCF    03.6
0039:  MOVF   28,W
003A:  BSF    03.6
003B:  MOVWF  0F
003C:  BCF    03.6
003D:  MOVF   29,W
003E:  BSF    03.6
003F:  MOVWF  0C
0040:  BCF    03.6
0041:  MOVF   2A,W
0042:  BSF    03.6
0043:  MOVWF  0E
0044:  BCF    03.6
0045:  MOVF   20,W
0046:  MOVWF  0A
0047:  SWAPF  21,W
0048:  MOVWF  03
0049:  SWAPF  7F,F
004A:  SWAPF  7F,W
004B:  RETFIE
004C:  BCF    0A.3
004D:  BCF    0A.4
004E:  GOTO   04F
.................... //#include <pid.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
*
0065:  DATA D4,32
0066:  DATA 6D,38
0067:  DATA 3A,10
0068:  DATA 25,33
0069:  DATA 00,00
006A:  DATA A0,22
006B:  DATA 72,39
006C:  DATA 6F,39
006D:  DATA 21,10
006E:  DATA 00,00
006F:  DATA D0,24
0070:  DATA 44,1D
0071:  DATA A0,12
0072:  DATA 66,10
0073:  DATA 00,01
0074:  DATA F3,32
0075:  DATA 74,1D
0076:  DATA A0,12
0077:  DATA 69,05
0078:  DATA 80,33
*
0148:  MOVLW  8E
0149:  MOVWF  77
014A:  MOVF   5E,W
014B:  MOVWF  78
014C:  MOVF   5D,W
014D:  MOVWF  79
014E:  CLRF   7A
014F:  BTFSS  5E.7
0150:  GOTO   156
0151:  COMF   78,F
0152:  COMF   79,F
0153:  INCF   79,F
0154:  BTFSC  03.2
0155:  INCF   78,F
0156:  MOVF   78,F
0157:  BTFSS  03.2
0158:  GOTO   163
0159:  MOVF   79,W
015A:  MOVWF  78
015B:  CLRF   79
015C:  MOVLW  08
015D:  SUBWF  77,F
015E:  MOVF   78,F
015F:  BTFSS  03.2
0160:  GOTO   163
0161:  CLRF   77
0162:  GOTO   16C
0163:  BCF    03.0
0164:  BTFSC  78.7
0165:  GOTO   16A
0166:  RLF    79,F
0167:  RLF    78,F
0168:  DECF   77,F
0169:  GOTO   163
016A:  BTFSS  5E.7
016B:  BCF    78.7
016C:  BSF    0A.3
016D:  BCF    0A.4
016E:  GOTO   059 (RETURN)
016F:  MOVF   65,W
0170:  BTFSC  03.2
0171:  GOTO   234
0172:  MOVWF  71
0173:  MOVF   69,W
0174:  BTFSC  03.2
0175:  GOTO   234
0176:  SUBWF  71,F
0177:  BTFSS  03.0
0178:  GOTO   17E
0179:  MOVLW  7F
017A:  ADDWF  71,F
017B:  BTFSC  03.0
017C:  GOTO   234
017D:  GOTO   184
017E:  MOVLW  81
017F:  SUBWF  71,F
0180:  BTFSS  03.0
0181:  GOTO   234
0182:  BTFSC  03.2
0183:  GOTO   234
0184:  MOVF   71,W
0185:  MOVWF  77
0186:  CLRF   78
0187:  CLRF   79
0188:  CLRF   7A
0189:  CLRF   70
018A:  MOVF   66,W
018B:  MOVWF  6F
018C:  BSF    6F.7
018D:  MOVF   67,W
018E:  MOVWF  6E
018F:  MOVF   68,W
0190:  MOVWF  6D
0191:  MOVLW  19
0192:  MOVWF  71
0193:  MOVF   6C,W
0194:  SUBWF  6D,F
0195:  BTFSC  03.0
0196:  GOTO   1A7
0197:  MOVLW  01
0198:  SUBWF  6E,F
0199:  BTFSC  03.0
019A:  GOTO   1A7
019B:  SUBWF  6F,F
019C:  BTFSC  03.0
019D:  GOTO   1A7
019E:  SUBWF  70,F
019F:  BTFSC  03.0
01A0:  GOTO   1A7
01A1:  INCF   70,F
01A2:  INCF   6F,F
01A3:  INCF   6E,F
01A4:  MOVF   6C,W
01A5:  ADDWF  6D,F
01A6:  GOTO   1D9
01A7:  MOVF   6B,W
01A8:  SUBWF  6E,F
01A9:  BTFSC  03.0
01AA:  GOTO   1C2
01AB:  MOVLW  01
01AC:  SUBWF  6F,F
01AD:  BTFSC  03.0
01AE:  GOTO   1C2
01AF:  SUBWF  70,F
01B0:  BTFSC  03.0
01B1:  GOTO   1C2
01B2:  INCF   70,F
01B3:  INCF   6F,F
01B4:  MOVF   6B,W
01B5:  ADDWF  6E,F
01B6:  MOVF   6C,W
01B7:  ADDWF  6D,F
01B8:  BTFSS  03.0
01B9:  GOTO   1D9
01BA:  INCF   6E,F
01BB:  BTFSS  03.2
01BC:  GOTO   1D9
01BD:  INCF   6F,F
01BE:  BTFSS  03.2
01BF:  GOTO   1D9
01C0:  INCF   70,F
01C1:  GOTO   1D9
01C2:  MOVF   6A,W
01C3:  IORLW  80
01C4:  SUBWF  6F,F
01C5:  BTFSC  03.0
01C6:  GOTO   1D8
01C7:  MOVLW  01
01C8:  SUBWF  70,F
01C9:  BTFSC  03.0
01CA:  GOTO   1D8
01CB:  INCF   70,F
01CC:  MOVF   6A,W
01CD:  IORLW  80
01CE:  ADDWF  6F,F
01CF:  MOVF   6B,W
01D0:  ADDWF  6E,F
01D1:  BTFSS  03.0
01D2:  GOTO   1B6
01D3:  INCF   6F,F
01D4:  BTFSS  03.2
01D5:  GOTO   1B6
01D6:  INCF   70,F
01D7:  GOTO   1B6
01D8:  BSF    7A.0
01D9:  DECFSZ 71,F
01DA:  GOTO   1DC
01DB:  GOTO   1E7
01DC:  BCF    03.0
01DD:  RLF    6D,F
01DE:  RLF    6E,F
01DF:  RLF    6F,F
01E0:  RLF    70,F
01E1:  BCF    03.0
01E2:  RLF    7A,F
01E3:  RLF    79,F
01E4:  RLF    78,F
01E5:  RLF    72,F
01E6:  GOTO   193
01E7:  BTFSS  72.0
01E8:  GOTO   1EF
01E9:  BCF    03.0
01EA:  RRF    78,F
01EB:  RRF    79,F
01EC:  RRF    7A,F
01ED:  RRF    72,F
01EE:  GOTO   1F2
01EF:  DECF   77,F
01F0:  BTFSC  03.2
01F1:  GOTO   234
01F2:  BTFSC  72.7
01F3:  GOTO   21B
01F4:  BCF    03.0
01F5:  RLF    6D,F
01F6:  RLF    6E,F
01F7:  RLF    6F,F
01F8:  RLF    70,F
01F9:  MOVF   6C,W
01FA:  SUBWF  6D,F
01FB:  BTFSC  03.0
01FC:  GOTO   207
01FD:  MOVLW  01
01FE:  SUBWF  6E,F
01FF:  BTFSC  03.0
0200:  GOTO   207
0201:  SUBWF  6F,F
0202:  BTFSC  03.0
0203:  GOTO   207
0204:  SUBWF  70,F
0205:  BTFSS  03.0
0206:  GOTO   22A
0207:  MOVF   6B,W
0208:  SUBWF  6E,F
0209:  BTFSC  03.0
020A:  GOTO   212
020B:  MOVLW  01
020C:  SUBWF  6F,F
020D:  BTFSC  03.0
020E:  GOTO   212
020F:  SUBWF  70,F
0210:  BTFSS  03.0
0211:  GOTO   22A
0212:  MOVF   6A,W
0213:  IORLW  80
0214:  SUBWF  6F,F
0215:  BTFSC  03.0
0216:  GOTO   21B
0217:  MOVLW  01
0218:  SUBWF  70,F
0219:  BTFSS  03.0
021A:  GOTO   22A
021B:  INCF   7A,F
021C:  BTFSS  03.2
021D:  GOTO   22A
021E:  INCF   79,F
021F:  BTFSS  03.2
0220:  GOTO   22A
0221:  INCF   78,F
0222:  BTFSS  03.2
0223:  GOTO   22A
0224:  INCF   77,F
0225:  BTFSC  03.2
0226:  GOTO   234
0227:  RRF    78,F
0228:  RRF    79,F
0229:  RRF    7A,F
022A:  MOVF   66,W
022B:  MOVWF  71
022C:  MOVF   6A,W
022D:  XORWF  71,F
022E:  BTFSS  71.7
022F:  GOTO   232
0230:  BSF    78.7
0231:  GOTO   238
0232:  BCF    78.7
0233:  GOTO   238
0234:  CLRF   77
0235:  CLRF   78
0236:  CLRF   79
0237:  CLRF   7A
0238:  RETURN
*
025D:  MOVF   0B,W
025E:  MOVWF  5E
025F:  BCF    0B.7
0260:  BSF    03.5
0261:  BSF    03.6
0262:  BSF    0C.7
0263:  BSF    0C.0
0264:  NOP
0265:  NOP
0266:  BCF    03.5
0267:  BCF    03.6
0268:  BTFSC  5E.7
0269:  BSF    0B.7
026A:  BTFSC  03.0
026B:  GOTO   294
026C:  BSF    03.6
026D:  MOVF   0C,W
026E:  ANDLW  7F
026F:  BCF    03.6
0270:  MOVWF  5E
0271:  BSF    03.6
0272:  MOVF   0D,W
0273:  BCF    03.6
0274:  MOVWF  5F
0275:  BSF    03.6
0276:  MOVF   0F,W
0277:  BCF    03.6
0278:  MOVWF  60
0279:  MOVF   5E,W
027A:  MOVWF  6A
027B:  CALL   239
027C:  MOVF   5F,W
027D:  BSF    03.6
027E:  MOVWF  0D
027F:  BCF    03.6
0280:  MOVF   60,W
0281:  BSF    03.6
0282:  MOVWF  0F
0283:  BCF    03.6
0284:  MOVF   0B,W
0285:  MOVWF  61
0286:  BCF    0B.7
0287:  BSF    03.5
0288:  BSF    03.6
0289:  BSF    0C.7
028A:  BSF    0C.0
028B:  NOP
028C:  NOP
028D:  BCF    03.5
028E:  BCF    03.6
028F:  BTFSC  61.7
0290:  BSF    0B.7
0291:  DECFSZ 5D,F
0292:  GOTO   294
0293:  GOTO   2B3
0294:  BSF    03.6
0295:  RLF    0C,W
0296:  RLF    0E,W
0297:  ANDLW  7F
0298:  BCF    03.6
0299:  MOVWF  5E
029A:  BSF    03.6
029B:  MOVF   0D,W
029C:  BCF    03.6
029D:  MOVWF  5F
029E:  BSF    03.6
029F:  MOVF   0F,W
02A0:  BCF    03.6
02A1:  MOVWF  60
02A2:  MOVF   5E,W
02A3:  MOVWF  6A
02A4:  CALL   239
02A5:  MOVF   5F,W
02A6:  BSF    03.6
02A7:  MOVWF  0D
02A8:  BCF    03.6
02A9:  MOVF   60,W
02AA:  BSF    03.6
02AB:  MOVWF  0F
02AC:  INCF   0D,F
02AD:  BTFSC  03.2
02AE:  INCF   0F,F
02AF:  BCF    03.0
02B0:  BCF    03.6
02B1:  DECFSZ 5D,F
02B2:  GOTO   25D
02B3:  RETURN
02B4:  MOVF   6A,W
02B5:  BTFSC  03.2
02B6:  GOTO   324
02B7:  MOVWF  72
02B8:  MOVF   6E,W
02B9:  BTFSC  03.2
02BA:  GOTO   324
02BB:  ADDWF  72,F
02BC:  BTFSC  03.0
02BD:  GOTO   2C5
02BE:  MOVLW  7F
02BF:  SUBWF  72,F
02C0:  BTFSS  03.0
02C1:  GOTO   324
02C2:  BTFSC  03.2
02C3:  GOTO   324
02C4:  GOTO   2C9
02C5:  MOVLW  81
02C6:  ADDWF  72,F
02C7:  BTFSC  03.0
02C8:  GOTO   324
02C9:  MOVF   72,W
02CA:  MOVWF  77
02CB:  CLRF   78
02CC:  CLRF   79
02CD:  CLRF   7A
02CE:  MOVF   6B,W
02CF:  MOVWF  76
02D0:  BSF    76.7
02D1:  MOVF   6C,W
02D2:  MOVWF  75
02D3:  MOVF   6D,W
02D4:  MOVWF  74
02D5:  MOVLW  18
02D6:  MOVWF  72
02D7:  CLRF   73
02D8:  BTFSS  74.0
02D9:  GOTO   2F2
02DA:  MOVF   71,W
02DB:  ADDWF  7A,F
02DC:  BTFSS  03.0
02DD:  GOTO   2E4
02DE:  INCF   79,F
02DF:  BTFSS  03.2
02E0:  GOTO   2E4
02E1:  INCF   78,F
02E2:  BTFSC  03.2
02E3:  BSF    73.7
02E4:  MOVF   70,W
02E5:  ADDWF  79,F
02E6:  BTFSS  03.0
02E7:  GOTO   2EB
02E8:  INCF   78,F
02E9:  BTFSC  03.2
02EA:  BSF    73.7
02EB:  MOVF   6F,W
02EC:  MOVWF  6C
02ED:  BSF    6C.7
02EE:  MOVF   6C,W
02EF:  ADDWF  78,F
02F0:  BTFSC  03.0
02F1:  BSF    73.7
02F2:  RLF    73,F
02F3:  RRF    78,F
02F4:  RRF    79,F
02F5:  RRF    7A,F
02F6:  RRF    76,F
02F7:  RRF    75,F
02F8:  RRF    74,F
02F9:  BCF    03.0
02FA:  DECFSZ 72,F
02FB:  GOTO   2D7
02FC:  MOVLW  01
02FD:  ADDWF  77,F
02FE:  BTFSC  03.0
02FF:  GOTO   324
0300:  BTFSC  78.7
0301:  GOTO   309
0302:  RLF    76,F
0303:  RLF    7A,F
0304:  RLF    79,F
0305:  RLF    78,F
0306:  DECF   77,F
0307:  BTFSC  03.2
0308:  GOTO   324
0309:  BTFSS  76.7
030A:  GOTO   31A
030B:  INCF   7A,F
030C:  BTFSS  03.2
030D:  GOTO   31A
030E:  INCF   79,F
030F:  BTFSS  03.2
0310:  GOTO   31A
0311:  INCF   78,F
0312:  BTFSS  03.2
0313:  GOTO   31A
0314:  RRF    78,F
0315:  RRF    79,F
0316:  RRF    7A,F
0317:  INCF   77,F
0318:  BTFSC  03.2
0319:  GOTO   324
031A:  MOVF   6B,W
031B:  MOVWF  73
031C:  MOVF   6F,W
031D:  XORWF  73,F
031E:  BTFSS  73.7
031F:  GOTO   322
0320:  BSF    78.7
0321:  GOTO   328
0322:  BCF    78.7
0323:  GOTO   328
0324:  CLRF   77
0325:  CLRF   78
0326:  CLRF   79
0327:  CLRF   7A
0328:  RETURN
0329:  BTFSC  03.1
032A:  GOTO   32E
032B:  MOVLW  72
032C:  MOVWF  04
032D:  BCF    03.7
032E:  CLRF   77
032F:  CLRF   78
0330:  CLRF   79
0331:  CLRF   7A
0332:  CLRF   72
0333:  CLRF   73
0334:  CLRF   74
0335:  CLRF   75
0336:  MOVF   71,W
0337:  IORWF  70,W
0338:  IORWF  6F,W
0339:  IORWF  6E,W
033A:  BTFSC  03.2
033B:  GOTO   36C
033C:  MOVLW  20
033D:  MOVWF  76
033E:  BCF    03.0
033F:  RLF    6A,F
0340:  RLF    6B,F
0341:  RLF    6C,F
0342:  RLF    6D,F
0343:  RLF    72,F
0344:  RLF    73,F
0345:  RLF    74,F
0346:  RLF    75,F
0347:  MOVF   71,W
0348:  SUBWF  75,W
0349:  BTFSS  03.2
034A:  GOTO   355
034B:  MOVF   70,W
034C:  SUBWF  74,W
034D:  BTFSS  03.2
034E:  GOTO   355
034F:  MOVF   6F,W
0350:  SUBWF  73,W
0351:  BTFSS  03.2
0352:  GOTO   355
0353:  MOVF   6E,W
0354:  SUBWF  72,W
0355:  BTFSS  03.0
0356:  GOTO   366
0357:  MOVF   6E,W
0358:  SUBWF  72,F
0359:  MOVF   6F,W
035A:  BTFSS  03.0
035B:  INCFSZ 6F,W
035C:  SUBWF  73,F
035D:  MOVF   70,W
035E:  BTFSS  03.0
035F:  INCFSZ 70,W
0360:  SUBWF  74,F
0361:  MOVF   71,W
0362:  BTFSS  03.0
0363:  INCFSZ 71,W
0364:  SUBWF  75,F
0365:  BSF    03.0
0366:  RLF    77,F
0367:  RLF    78,F
0368:  RLF    79,F
0369:  RLF    7A,F
036A:  DECFSZ 76,F
036B:  GOTO   33E
036C:  MOVF   72,W
036D:  MOVWF  00
036E:  INCF   04,F
036F:  MOVF   73,W
0370:  MOVWF  00
0371:  INCF   04,F
0372:  MOVF   74,W
0373:  MOVWF  00
0374:  INCF   04,F
0375:  MOVF   75,W
0376:  MOVWF  00
0377:  RETURN
0378:  MOVF   04,W
0379:  MOVWF  62
037A:  MOVF   61,W
037B:  MOVWF  64
037C:  BTFSC  03.2
037D:  GOTO   397
037E:  MOVF   60,W
037F:  MOVWF  6D
0380:  MOVF   5F,W
0381:  MOVWF  6C
0382:  MOVF   5E,W
0383:  MOVWF  6B
0384:  MOVF   5D,W
0385:  MOVWF  6A
0386:  CLRF   71
0387:  CLRF   70
0388:  MOVLW  20
0389:  MOVWF  6F
038A:  MOVLW  82
038B:  MOVWF  6E
038C:  CALL   2B4
038D:  MOVF   7A,W
038E:  MOVWF  60
038F:  MOVF   79,W
0390:  MOVWF  5F
0391:  MOVF   78,W
0392:  MOVWF  5E
0393:  MOVF   77,W
0394:  MOVWF  5D
0395:  DECFSZ 64,F
0396:  GOTO   37E
0397:  MOVF   60,W
0398:  MOVWF  6D
0399:  MOVF   5F,W
039A:  MOVWF  6C
039B:  MOVF   5E,W
039C:  MOVWF  6B
039D:  MOVF   5D,W
039E:  MOVWF  6A
039F:  MOVF   6A,W
03A0:  SUBLW  B6
03A1:  MOVWF  6A
03A2:  CLRF   7A
03A3:  MOVF   6B,W
03A4:  MOVWF  6E
03A5:  BSF    6B.7
03A6:  BCF    03.0
03A7:  RRF    6B,F
03A8:  RRF    6C,F
03A9:  RRF    6D,F
03AA:  RRF    7A,F
03AB:  RRF    79,F
03AC:  RRF    78,F
03AD:  RRF    77,F
03AE:  DECFSZ 6A,F
03AF:  GOTO   3A6
03B0:  BTFSS  6E.7
03B1:  GOTO   3BD
03B2:  COMF   77,F
03B3:  COMF   78,F
03B4:  COMF   79,F
03B5:  COMF   7A,F
03B6:  INCF   77,F
03B7:  BTFSC  03.2
03B8:  INCF   78,F
03B9:  BTFSC  03.2
03BA:  INCF   79,F
03BB:  BTFSC  03.2
03BC:  INCF   7A,F
03BD:  MOVF   7A,W
03BE:  MOVWF  60
03BF:  MOVF   79,W
03C0:  MOVWF  5F
03C1:  MOVF   78,W
03C2:  MOVWF  5E
03C3:  MOVF   77,W
03C4:  MOVWF  5D
03C5:  BTFSS  60.7
03C6:  GOTO   3D4
03C7:  DECF   62,F
03C8:  BSF    62.5
03C9:  COMF   5D,F
03CA:  COMF   5E,F
03CB:  COMF   5F,F
03CC:  COMF   60,F
03CD:  INCF   5D,F
03CE:  BTFSC  03.2
03CF:  INCF   5E,F
03D0:  BTFSC  03.2
03D1:  INCF   5F,F
03D2:  BTFSC  03.2
03D3:  INCF   60,F
03D4:  MOVLW  3B
03D5:  MOVWF  69
03D6:  MOVLW  9A
03D7:  MOVWF  68
03D8:  MOVLW  CA
03D9:  MOVWF  67
03DA:  CLRF   66
03DB:  MOVLW  0A
03DC:  MOVWF  64
03DD:  MOVF   61,W
03DE:  BTFSC  03.2
03DF:  INCF   62,F
03E0:  BSF    03.1
03E1:  MOVLW  5D
03E2:  MOVWF  04
03E3:  BCF    03.7
03E4:  MOVF   60,W
03E5:  MOVWF  6D
03E6:  MOVF   5F,W
03E7:  MOVWF  6C
03E8:  MOVF   5E,W
03E9:  MOVWF  6B
03EA:  MOVF   5D,W
03EB:  MOVWF  6A
03EC:  MOVF   69,W
03ED:  MOVWF  71
03EE:  MOVF   68,W
03EF:  MOVWF  70
03F0:  MOVF   67,W
03F1:  MOVWF  6F
03F2:  MOVF   66,W
03F3:  MOVWF  6E
03F4:  CALL   329
03F5:  MOVF   78,W
03F6:  MOVF   77,F
03F7:  BTFSS  03.2
03F8:  GOTO   40C
03F9:  INCF   61,W
03FA:  SUBWF  64,W
03FB:  BTFSC  03.2
03FC:  GOTO   40C
03FD:  MOVF   62,W
03FE:  BTFSC  03.2
03FF:  GOTO   40E
0400:  ANDLW  0F
0401:  SUBWF  64,W
0402:  BTFSC  03.2
0403:  GOTO   406
0404:  BTFSC  03.0
0405:  GOTO   43E
0406:  BTFSC  62.7
0407:  GOTO   43E
0408:  BTFSC  62.6
0409:  GOTO   40E
040A:  MOVLW  20
040B:  GOTO   43A
040C:  MOVLW  20
040D:  ANDWF  62,F
040E:  BTFSS  62.5
040F:  GOTO   41C
0410:  BCF    62.5
0411:  MOVF   61,W
0412:  BTFSS  03.2
0413:  DECF   62,F
0414:  MOVF   77,W
0415:  MOVWF  62
0416:  MOVLW  2D
0417:  MOVWF  6A
0418:  CALL   239
0419:  MOVF   62,W
041A:  MOVWF  77
041B:  CLRF   62
041C:  MOVF   61,W
041D:  SUBWF  64,W
041E:  BTFSS  03.2
041F:  GOTO   42A
0420:  MOVF   77,W
0421:  MOVWF  62
0422:  MOVLW  2E
0423:  MOVWF  6A
0424:  CALL   239
0425:  MOVF   62,W
0426:  MOVWF  77
0427:  MOVLW  20
0428:  ANDWF  62,F
0429:  MOVLW  00
042A:  MOVLW  30
042B:  BTFSS  62.5
042C:  GOTO   43A
042D:  BCF    62.5
042E:  MOVF   61,W
042F:  BTFSS  03.2
0430:  DECF   62,F
0431:  MOVF   77,W
0432:  MOVWF  62
0433:  MOVLW  2D
0434:  MOVWF  6A
0435:  CALL   239
0436:  MOVF   62,W
0437:  MOVWF  77
0438:  CLRF   62
0439:  MOVLW  30
043A:  ADDWF  77,F
043B:  MOVF   77,W
043C:  MOVWF  6A
043D:  CALL   239
043E:  BCF    03.1
043F:  MOVF   69,W
0440:  MOVWF  6D
0441:  MOVF   68,W
0442:  MOVWF  6C
0443:  MOVF   67,W
0444:  MOVWF  6B
0445:  MOVF   66,W
0446:  MOVWF  6A
0447:  CLRF   71
0448:  CLRF   70
0449:  CLRF   6F
044A:  MOVLW  0A
044B:  MOVWF  6E
044C:  CALL   329
044D:  MOVF   7A,W
044E:  MOVWF  69
044F:  MOVF   79,W
0450:  MOVWF  68
0451:  MOVF   78,W
0452:  MOVWF  67
0453:  MOVF   77,W
0454:  MOVWF  66
0455:  DECFSZ 64,F
0456:  GOTO   3E0
0457:  RETURN
0458:  MOVF   0B,W
0459:  MOVWF  5D
045A:  BCF    0B.7
045B:  BSF    03.5
045C:  BSF    03.6
045D:  BSF    0C.7
045E:  BSF    0C.0
045F:  NOP
0460:  NOP
0461:  BCF    03.5
0462:  BCF    03.6
0463:  BTFSC  5D.7
0464:  BSF    0B.7
0465:  BSF    03.6
0466:  MOVF   0C,W
0467:  ANDLW  7F
0468:  BTFSC  03.2
0469:  GOTO   4AC
046A:  BCF    03.6
046B:  MOVWF  5D
046C:  BSF    03.6
046D:  MOVF   0D,W
046E:  BCF    03.6
046F:  MOVWF  5E
0470:  BSF    03.6
0471:  MOVF   0F,W
0472:  BCF    03.6
0473:  MOVWF  5F
0474:  MOVF   5D,W
0475:  MOVWF  6A
0476:  CALL   239
0477:  MOVF   5E,W
0478:  BSF    03.6
0479:  MOVWF  0D
047A:  BCF    03.6
047B:  MOVF   5F,W
047C:  BSF    03.6
047D:  MOVWF  0F
047E:  BCF    03.6
047F:  MOVF   0B,W
0480:  MOVWF  60
0481:  BCF    0B.7
0482:  BSF    03.5
0483:  BSF    03.6
0484:  BSF    0C.7
0485:  BSF    0C.0
0486:  NOP
0487:  NOP
0488:  BCF    03.5
0489:  BCF    03.6
048A:  BTFSC  60.7
048B:  BSF    0B.7
048C:  BSF    03.6
048D:  RLF    0C,W
048E:  RLF    0E,W
048F:  ANDLW  7F
0490:  BTFSC  03.2
0491:  GOTO   4AC
0492:  BCF    03.6
0493:  MOVWF  5D
0494:  BSF    03.6
0495:  MOVF   0D,W
0496:  BCF    03.6
0497:  MOVWF  5E
0498:  BSF    03.6
0499:  MOVF   0F,W
049A:  BCF    03.6
049B:  MOVWF  5F
049C:  MOVF   5D,W
049D:  MOVWF  6A
049E:  CALL   239
049F:  MOVF   5E,W
04A0:  BSF    03.6
04A1:  MOVWF  0D
04A2:  BCF    03.6
04A3:  MOVF   5F,W
04A4:  BSF    03.6
04A5:  MOVWF  0F
04A6:  INCF   0D,F
04A7:  BTFSC  03.2
04A8:  INCF   0F,F
04A9:  BCF    03.6
04AA:  GOTO   458
04AB:  BSF    03.6
04AC:  BCF    03.6
04AD:  BSF    0A.3
04AE:  BCF    0A.4
04AF:  GOTO   09E (RETURN)
04B0:  MOVLW  8E
04B1:  MOVWF  77
04B2:  MOVF   5E,W
04B3:  MOVWF  78
04B4:  MOVF   5D,W
04B5:  MOVWF  79
04B6:  CLRF   7A
04B7:  MOVF   78,F
04B8:  BTFSS  03.2
04B9:  GOTO   4C4
04BA:  MOVF   79,W
04BB:  MOVWF  78
04BC:  CLRF   79
04BD:  MOVLW  08
04BE:  SUBWF  77,F
04BF:  MOVF   78,F
04C0:  BTFSS  03.2
04C1:  GOTO   4C4
04C2:  CLRF   77
04C3:  GOTO   4CC
04C4:  BCF    03.0
04C5:  BTFSC  78.7
04C6:  GOTO   4CB
04C7:  RLF    79,F
04C8:  RLF    78,F
04C9:  DECF   77,F
04CA:  GOTO   4C4
04CB:  BCF    78.7
04CC:  BSF    0A.3
04CD:  BCF    0A.4
04CE:  GOTO   0A4 (RETURN)
04CF:  MOVLW  80
04D0:  BTFSC  03.1
04D1:  XORWF  66,F
04D2:  CLRF   6B
04D3:  CLRF   6C
04D4:  MOVF   62,W
04D5:  MOVWF  6A
04D6:  MOVF   66,W
04D7:  XORWF  6A,F
04D8:  MOVF   61,W
04D9:  BTFSC  03.2
04DA:  GOTO   5BF
04DB:  MOVWF  69
04DC:  MOVWF  77
04DD:  MOVF   65,W
04DE:  BTFSC  03.2
04DF:  GOTO   5C8
04E0:  SUBWF  69,F
04E1:  BTFSC  03.2
04E2:  GOTO   564
04E3:  BTFSS  03.0
04E4:  GOTO   522
04E5:  MOVF   66,W
04E6:  MOVWF  6F
04E7:  BSF    6F.7
04E8:  MOVF   67,W
04E9:  MOVWF  6E
04EA:  MOVF   68,W
04EB:  MOVWF  6D
04EC:  CLRF   6C
04ED:  BCF    03.0
04EE:  RRF    6F,F
04EF:  RRF    6E,F
04F0:  RRF    6D,F
04F1:  RRF    6C,F
04F2:  DECFSZ 69,F
04F3:  GOTO   4EC
04F4:  BTFSS  6A.7
04F5:  GOTO   4F9
04F6:  BSF    6B.0
04F7:  GOTO   5DC
04F8:  BCF    6B.0
04F9:  BCF    69.0
04FA:  BSF    6B.4
04FB:  MOVLW  64
04FC:  MOVWF  04
04FD:  BCF    03.7
04FE:  GOTO   5F1
04FF:  BCF    6B.4
0500:  BTFSC  6A.7
0501:  GOTO   50C
0502:  BTFSS  69.0
0503:  GOTO   517
0504:  RRF    6F,F
0505:  RRF    6E,F
0506:  RRF    6D,F
0507:  RRF    6C,F
0508:  INCF   77,F
0509:  BTFSC  03.2
050A:  GOTO   5D7
050B:  GOTO   517
050C:  BTFSC  6F.7
050D:  GOTO   51A
050E:  BCF    03.0
050F:  RLF    6C,F
0510:  RLF    6D,F
0511:  RLF    6E,F
0512:  RLF    6F,F
0513:  DECF   77,F
0514:  BTFSC  03.2
0515:  GOTO   5D7
0516:  GOTO   50C
0517:  BSF    6B.6
0518:  GOTO   584
0519:  BCF    6B.6
051A:  MOVF   62,W
051B:  MOVWF  6A
051C:  BTFSS  6A.7
051D:  GOTO   520
051E:  BSF    6F.7
051F:  GOTO   5D0
0520:  BCF    6F.7
0521:  GOTO   5D0
0522:  MOVF   65,W
0523:  MOVWF  69
0524:  MOVWF  77
0525:  MOVF   61,W
0526:  SUBWF  69,F
0527:  MOVF   62,W
0528:  MOVWF  6F
0529:  BSF    6F.7
052A:  MOVF   63,W
052B:  MOVWF  6E
052C:  MOVF   64,W
052D:  MOVWF  6D
052E:  CLRF   6C
052F:  BCF    03.0
0530:  RRF    6F,F
0531:  RRF    6E,F
0532:  RRF    6D,F
0533:  RRF    6C,F
0534:  DECFSZ 69,F
0535:  GOTO   52E
0536:  BTFSS  6A.7
0537:  GOTO   53B
0538:  BSF    6B.1
0539:  GOTO   5DC
053A:  BCF    6B.1
053B:  BCF    69.0
053C:  BSF    6B.5
053D:  MOVLW  68
053E:  MOVWF  04
053F:  BCF    03.7
0540:  GOTO   5F1
0541:  BCF    6B.5
0542:  BTFSC  6A.7
0543:  GOTO   54E
0544:  BTFSS  69.0
0545:  GOTO   559
0546:  RRF    6F,F
0547:  RRF    6E,F
0548:  RRF    6D,F
0549:  RRF    6C,F
054A:  INCF   77,F
054B:  BTFSC  03.2
054C:  GOTO   5D7
054D:  GOTO   559
054E:  BTFSC  6F.7
054F:  GOTO   55C
0550:  BCF    03.0
0551:  RLF    6C,F
0552:  RLF    6D,F
0553:  RLF    6E,F
0554:  RLF    6F,F
0555:  DECF   77,F
0556:  BTFSC  03.2
0557:  GOTO   5D7
0558:  GOTO   54E
0559:  BSF    6B.7
055A:  GOTO   584
055B:  BCF    6B.7
055C:  MOVF   66,W
055D:  MOVWF  6A
055E:  BTFSS  6A.7
055F:  GOTO   562
0560:  BSF    6F.7
0561:  GOTO   5D0
0562:  BCF    6F.7
0563:  GOTO   5D0
0564:  MOVF   66,W
0565:  MOVWF  6F
0566:  BSF    6F.7
0567:  MOVF   67,W
0568:  MOVWF  6E
0569:  MOVF   68,W
056A:  MOVWF  6D
056B:  BTFSS  6A.7
056C:  GOTO   571
056D:  BCF    6F.7
056E:  BSF    6B.2
056F:  GOTO   5DC
0570:  BCF    6B.2
0571:  CLRF   6C
0572:  BCF    69.0
0573:  MOVLW  64
0574:  MOVWF  04
0575:  BCF    03.7
0576:  GOTO   5F1
0577:  BTFSC  6A.7
0578:  GOTO   59A
0579:  MOVF   62,W
057A:  MOVWF  6A
057B:  BTFSS  69.0
057C:  GOTO   584
057D:  RRF    6F,F
057E:  RRF    6E,F
057F:  RRF    6D,F
0580:  RRF    6C,F
0581:  INCF   77,F
0582:  BTFSC  03.2
0583:  GOTO   5D7
0584:  BTFSS  6C.7
0585:  GOTO   595
0586:  INCF   6D,F
0587:  BTFSS  03.2
0588:  GOTO   595
0589:  INCF   6E,F
058A:  BTFSS  03.2
058B:  GOTO   595
058C:  INCF   6F,F
058D:  BTFSS  03.2
058E:  GOTO   595
058F:  RRF    6F,F
0590:  RRF    6E,F
0591:  RRF    6D,F
0592:  INCF   77,F
0593:  BTFSC  03.2
0594:  GOTO   5D7
0595:  BTFSC  6B.6
0596:  GOTO   519
0597:  BTFSC  6B.7
0598:  GOTO   55B
0599:  GOTO   5B9
059A:  MOVLW  80
059B:  XORWF  6F,F
059C:  BTFSS  6F.7
059D:  GOTO   5A2
059E:  GOTO   5DC
059F:  MOVF   66,W
05A0:  MOVWF  6A
05A1:  GOTO   5AF
05A2:  MOVF   62,W
05A3:  MOVWF  6A
05A4:  MOVF   6F,F
05A5:  BTFSS  03.2
05A6:  GOTO   5AF
05A7:  MOVF   6E,F
05A8:  BTFSS  03.2
05A9:  GOTO   5AF
05AA:  MOVF   6D,F
05AB:  BTFSS  03.2
05AC:  GOTO   5AF
05AD:  CLRF   77
05AE:  GOTO   5D0
05AF:  BTFSC  6F.7
05B0:  GOTO   5B9
05B1:  BCF    03.0
05B2:  RLF    6C,F
05B3:  RLF    6D,F
05B4:  RLF    6E,F
05B5:  RLF    6F,F
05B6:  DECFSZ 77,F
05B7:  GOTO   5AF
05B8:  GOTO   5D7
05B9:  BTFSS  6A.7
05BA:  GOTO   5BD
05BB:  BSF    6F.7
05BC:  GOTO   5D0
05BD:  BCF    6F.7
05BE:  GOTO   5D0
05BF:  MOVF   65,W
05C0:  MOVWF  77
05C1:  MOVF   66,W
05C2:  MOVWF  6F
05C3:  MOVF   67,W
05C4:  MOVWF  6E
05C5:  MOVF   68,W
05C6:  MOVWF  6D
05C7:  GOTO   5D0
05C8:  MOVF   61,W
05C9:  MOVWF  77
05CA:  MOVF   62,W
05CB:  MOVWF  6F
05CC:  MOVF   63,W
05CD:  MOVWF  6E
05CE:  MOVF   64,W
05CF:  MOVWF  6D
05D0:  MOVF   6F,W
05D1:  MOVWF  78
05D2:  MOVF   6E,W
05D3:  MOVWF  79
05D4:  MOVF   6D,W
05D5:  MOVWF  7A
05D6:  GOTO   60F
05D7:  CLRF   77
05D8:  CLRF   78
05D9:  CLRF   79
05DA:  CLRF   7A
05DB:  GOTO   60F
05DC:  CLRF   6C
05DD:  COMF   6D,F
05DE:  COMF   6E,F
05DF:  COMF   6F,F
05E0:  COMF   6C,F
05E1:  INCF   6C,F
05E2:  BTFSS  03.2
05E3:  GOTO   5EA
05E4:  INCF   6D,F
05E5:  BTFSS  03.2
05E6:  GOTO   5EA
05E7:  INCF   6E,F
05E8:  BTFSC  03.2
05E9:  INCF   6F,F
05EA:  BTFSC  6B.0
05EB:  GOTO   4F8
05EC:  BTFSC  6B.1
05ED:  GOTO   53A
05EE:  BTFSC  6B.2
05EF:  GOTO   570
05F0:  GOTO   59F
05F1:  MOVF   00,W
05F2:  ADDWF  6D,F
05F3:  BTFSS  03.0
05F4:  GOTO   5FB
05F5:  INCF   6E,F
05F6:  BTFSS  03.2
05F7:  GOTO   5FB
05F8:  INCF   6F,F
05F9:  BTFSC  03.2
05FA:  BSF    69.0
05FB:  DECF   04,F
05FC:  MOVF   00,W
05FD:  ADDWF  6E,F
05FE:  BTFSS  03.0
05FF:  GOTO   603
0600:  INCF   6F,F
0601:  BTFSC  03.2
0602:  BSF    69.0
0603:  DECF   04,F
0604:  MOVF   00,W
0605:  BTFSS  00.7
0606:  XORLW  80
0607:  ADDWF  6F,F
0608:  BTFSC  03.0
0609:  BSF    69.0
060A:  BTFSC  6B.4
060B:  GOTO   4FF
060C:  BTFSC  6B.5
060D:  GOTO   541
060E:  GOTO   577
060F:  RETURN
0610:  MOVF   64,W
0611:  CLRF   78
0612:  SUBWF  63,W
0613:  BTFSC  03.0
0614:  GOTO   618
0615:  MOVF   63,W
0616:  MOVWF  77
0617:  GOTO   624
0618:  CLRF   77
0619:  MOVLW  08
061A:  MOVWF  65
061B:  RLF    63,F
061C:  RLF    77,F
061D:  MOVF   64,W
061E:  SUBWF  77,W
061F:  BTFSC  03.0
0620:  MOVWF  77
0621:  RLF    78,F
0622:  DECFSZ 65,F
0623:  GOTO   61B
0624:  RETURN
0625:  MOVLW  20
0626:  BTFSS  5E.4
0627:  MOVLW  30
0628:  MOVWF  5F
0629:  MOVF   5D,W
062A:  MOVWF  77
062B:  BTFSS  5D.7
062C:  GOTO   635
062D:  COMF   77,F
062E:  INCF   77,F
062F:  MOVF   77,W
0630:  MOVWF  5D
0631:  MOVLW  2D
0632:  MOVWF  5F
0633:  BSF    5E.7
0634:  BSF    5E.0
0635:  MOVF   5D,W
0636:  MOVWF  63
0637:  MOVLW  64
0638:  MOVWF  64
0639:  CALL   610
063A:  MOVF   77,W
063B:  MOVWF  5D
063C:  MOVLW  30
063D:  ADDWF  78,W
063E:  MOVWF  60
063F:  MOVF   5D,W
0640:  MOVWF  63
0641:  MOVLW  0A
0642:  MOVWF  64
0643:  CALL   610
0644:  MOVLW  30
0645:  ADDWF  77,W
0646:  MOVWF  62
0647:  MOVLW  30
0648:  ADDWF  78,W
0649:  MOVWF  61
064A:  MOVF   5F,W
064B:  MOVWF  77
064C:  MOVLW  30
064D:  SUBWF  60,W
064E:  BTFSC  03.2
064F:  GOTO   654
0650:  BSF    5E.1
0651:  BTFSC  5E.7
0652:  BSF    5E.2
0653:  GOTO   668
0654:  MOVF   5F,W
0655:  MOVWF  60
0656:  MOVLW  20
0657:  MOVWF  5F
0658:  MOVLW  30
0659:  SUBWF  61,W
065A:  BTFSC  03.2
065B:  GOTO   660
065C:  BSF    5E.0
065D:  BTFSC  5E.7
065E:  BSF    5E.1
065F:  GOTO   668
0660:  BTFSS  03.2
0661:  BSF    5E.0
0662:  BTFSS  03.2
0663:  GOTO   668
0664:  MOVF   60,W
0665:  MOVWF  61
0666:  MOVLW  20
0667:  MOVWF  60
0668:  BTFSC  5E.2
0669:  GOTO   66F
066A:  BTFSC  5E.1
066B:  GOTO   672
066C:  BTFSC  5E.0
066D:  GOTO   675
066E:  GOTO   678
066F:  MOVF   5F,W
0670:  MOVWF  6A
0671:  CALL   239
0672:  MOVF   60,W
0673:  MOVWF  6A
0674:  CALL   239
0675:  MOVF   61,W
0676:  MOVWF  6A
0677:  CALL   239
0678:  MOVF   62,W
0679:  MOVWF  6A
067A:  CALL   239
067B:  BSF    0A.3
067C:  BCF    0A.4
067D:  GOTO   192 (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(crystal=20000000) 
*
0079:  MOVLW  03
007A:  SUBWF  65,F
007B:  BTFSS  03.0
007C:  GOTO   087
007D:  MOVLW  65
007E:  MOVWF  04
007F:  BCF    03.7
0080:  MOVF   00,W
0081:  BTFSC  03.2
0082:  GOTO   087
0083:  GOTO   085
0084:  GOTO   085
0085:  DECFSZ 00,F
0086:  GOTO   084
0087:  RETURN
*
067E:  MOVLW  5E
067F:  MOVWF  04
0680:  BCF    03.7
0681:  MOVF   00,W
0682:  BTFSC  03.2
0683:  GOTO   691
0684:  MOVLW  06
0685:  MOVWF  78
0686:  CLRF   77
0687:  DECFSZ 77,F
0688:  GOTO   687
0689:  DECFSZ 78,F
068A:  GOTO   686
068B:  MOVLW  7B
068C:  MOVWF  77
068D:  DECFSZ 77,F
068E:  GOTO   68D
068F:  DECFSZ 00,F
0690:  GOTO   684
0691:  BSF    0A.3
0692:  BCF    0A.4
0693:  GOTO   19E (RETURN)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_D0,bits=8,stream=PORT1) 
*
0239:  BCF    2B.6
023A:  MOVF   2B,W
023B:  BSF    03.5
023C:  MOVWF  07
023D:  BCF    03.5
023E:  BCF    07.6
023F:  MOVLW  08
0240:  MOVWF  78
0241:  GOTO   242
0242:  NOP
0243:  BSF    78.7
0244:  GOTO   253
0245:  BCF    78.7
0246:  RRF    6A,F
0247:  BTFSC  03.0
0248:  BSF    07.6
0249:  BTFSS  03.0
024A:  BCF    07.6
024B:  BSF    78.6
024C:  GOTO   253
024D:  BCF    78.6
024E:  DECFSZ 78,F
024F:  GOTO   246
0250:  GOTO   251
0251:  NOP
0252:  BSF    07.6
0253:  MOVLW  A7
0254:  MOVWF  04
0255:  DECFSZ 04,F
0256:  GOTO   255
0257:  GOTO   258
0258:  BTFSC  78.7
0259:  GOTO   245
025A:  BTFSC  78.6
025B:  GOTO   24D
025C:  RETURN
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... #if defined(__PCD__) 
....................    typedef unsigned int32 uintptr_t; 
....................    typedef signed int32 intptr_t; 
.................... #else 
....................    typedef unsigned int16 uintptr_t; 
....................    typedef signed int16 intptr_t; 
.................... #endif 
....................  
.................... #define INT8_C(val) ((int8_t)val) 
.................... #define UINT8_C(val) ((uint8_t)val) 
.................... #define INT16_C(val) ((int16_t)val) 
.................... #define UINT16_C(val) ((uint16_t)val) 
.................... #define INT32_C(val) ((int32_t)val) 
.................... #define UINT32_C(val) ((uint32_t)val) 
....................  
.................... #if defined(__PCD__) 
.................... #define INT64_C(val) ((int64_t)val) 
.................... #define UINT64_C(val) ((uint64_t)val) 
.................... #endif 
....................  
.................... /// TODO: 
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
083F:  BCF    03.5
0840:  CLRF   2C
0841:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #define PIN_DS18B20_DATA PIN_B5  
.................... #include <ds18b20.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                            ds18b20.c                              //// 
.................... ////                                                                   //// 
.................... //// Driver for Dallas DS18B20 digital thermometer, with Dallas one    //// 
.................... //// wire interface.                                                   //// 
.................... ////                                                                   //// 
.................... ////  ds18b20_init()                                                   //// 
.................... ////     Init the module and the driver.                               //// 
.................... ////                                                                   //// 
.................... ////  int1 = ds18b20_read(signed int16 *pTemp)                         //// 
.................... ////     Reads temperature from device and saves read value to pTemp   //// 
.................... ////     pointer.  Returns TRUE if we succesfully talked to the device //// 
.................... ////     and pTemp was updated; returns FALSE if there was an error    //// 
.................... ////     in communication and pTemp is not updated.                    //// 
.................... ////     This will deadlock the PICmicro while waiting for the         //// 
.................... ////     DS18B20 to return a conversion, which can take over 750ms.    //// 
.................... ////     Also this routine may get stuck in an infinite loop and not   //// 
.................... ////     return if there is a problem with the bus.                    //// 
.................... ////     To limit the deadlocking, use ds18b20_start_conversion() and  //// 
.................... ////     ds18b20_get_conversion() instead.                             //// 
.................... ////     The temperature returned is degrees C, but fractional;        //// 
.................... ////     divide by 16 to get the integer numerator.                    //// 
.................... ////                                                                   //// 
.................... //// int1 ds18b20_start_conversion(void)                               //// 
.................... ////     This starts a temperature conversion on the DS18B20.          //// 
.................... ////     Returns TRUE if communication was successful, FALSE if there  //// 
.................... ////     was something wrong with the bus or the device.               //// 
.................... ////                                                                   //// 
.................... //// int1 ds18b20_get_conversion(signed int16 *pTemp)                  //// 
.................... ////     After a conversion is started, you can either wait for Tconv  //// 
.................... ////     (which is 750ms for max resolution conversion) or poll        //// 
.................... ////     the bus with ds18b20_read_bit() (if it returns non-zero       //// 
.................... ////     then conversion is finished).  Once conversion is finished    //// 
.................... ////     then this function reads the conversion stored on the         //// 
.................... ////     DS18B20 device.                                               //// 
.................... ////                                                                   //// 
.................... ////                            CONNECTIONS                            //// 
.................... ////                                                                   //// 
.................... //// PIN_DS18B20_DATA                                                  //// 
.................... ////     #define this to the PIC GPIO pin connected to the DS18B20's   //// 
.................... ////     data pin.                                                     //// 
.................... ////     Example:  #define PIN_DS18B20_DATA PIN_D0                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2016 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... ////                                                                   //// 
.................... //// http://www.ccsinfo.com                                            //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /// begin config ////////////////////////////////////////////////////////// 
....................  
.................... #ifndef PIN_DS18B20_DATA 
.................... #define PIN_DS18B20_DATA PIN_B5 
.................... #endif 
....................  
.................... /// end config //////////////////////////////////////////////////////////// 
....................  
....................  
.................... void ds18b20_init(void) 
.................... { 
....................    output_float(PIN_DS18B20_DATA); 
.................... } 
....................  
.................... /* 
.................... This method will initialize the DS18B20 for transactions to occur 
.................... PARAMS: none 
.................... RETURNS: TRUE if start pulse response read from unit 
.................... */ 
.................... int1 ds18b20_start(void) 
*
0088:  BCF    63.0
.................... { 
....................    int1 ret = FALSE; 
....................     
....................    output_low(PIN_DS18B20_DATA); 
0089:  BSF    03.5
008A:  BCF    06.5
008B:  BCF    03.5
008C:  BCF    06.5
....................    delay_us(500); 
008D:  MOVLW  02
008E:  MOVWF  64
008F:  MOVLW  F9
0090:  MOVWF  65
0091:  CALL   079
0092:  DECFSZ 64,F
0093:  GOTO   08F
....................    output_float(PIN_DS18B20_DATA); 
0094:  BSF    03.5
0095:  BSF    06.5
....................    delay_us(70);//wait to read the SLAVES response 
0096:  MOVLW  74
0097:  MOVWF  77
0098:  DECFSZ 77,F
0099:  GOTO   098
009A:  NOP
....................    if (!input(PIN_DS18B20_DATA)) 
009B:  BSF    06.5
009C:  BCF    03.5
009D:  BTFSC  06.5
009E:  GOTO   0A7
....................    { 
....................       ret = TRUE; 
009F:  BSF    63.0
....................       delay_us(430); 
00A0:  MOVLW  02
00A1:  MOVWF  64
00A2:  MOVLW  D6
00A3:  MOVWF  65
00A4:  CALL   079
00A5:  DECFSZ 64,F
00A6:  GOTO   0A2
....................    } 
....................    return(ret); 
00A7:  MOVLW  00
00A8:  BTFSC  63.0
00A9:  MOVLW  01
00AA:  MOVWF  78
00AB:  RETURN
.................... } 
.................... /* 
.................... This method will write a bit to the DS18B20 following write time slots 
.................... PARAMS: int1 value to write 
.................... RETURNS: none 
.................... */ 
.................... void ds18b20_write(int1 value) 
.................... { 
....................    output_low(PIN_DS18B20_DATA);//drives output low for master 
*
00BA:  BSF    03.5
00BB:  BCF    06.5
00BC:  BCF    03.5
00BD:  BCF    06.5
....................    delay_us(2);//delays for 2us 
00BE:  MOVLW  03
00BF:  MOVWF  77
00C0:  DECFSZ 77,F
00C1:  GOTO   0C0
....................    output_bit(PIN_DS18B20_DATA,value);//sets MASTER to input mode to release pin 
00C2:  MOVF   66,F
00C3:  BTFSS  03.2
00C4:  GOTO   0C7
00C5:  BCF    06.5
00C6:  GOTO   0C8
00C7:  BSF    06.5
00C8:  BSF    03.5
00C9:  BCF    06.5
....................    delay_us(60); 
00CA:  MOVLW  63
00CB:  MOVWF  77
00CC:  DECFSZ 77,F
00CD:  GOTO   0CC
00CE:  GOTO   0CF
....................    output_float(PIN_DS18B20_DATA);//sets MASTER to input mode to release pin 
00CF:  BSF    06.5
....................    delay_us(2);//delays for 2 microseconds which is within 15us max 
00D0:  MOVLW  03
00D1:  MOVWF  77
00D2:  DECFSZ 77,F
00D3:  GOTO   0D2
.................... } 
.................... /* 
.................... This method will call write() for each bit of a byte to be sent 
.................... PARAMS: BYTE value to write 
.................... RETURNS: none 
.................... */ 
.................... void ds18b20_write_byte(unsigned int8 value) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=1;i<=8;++i) 
*
00AC:  MOVLW  01
00AD:  MOVWF  64
00AE:  MOVF   64,W
00AF:  SUBLW  08
00B0:  BTFSS  03.0
00B1:  GOTO   0D7
....................    { 
....................       ds18b20_write(shift_right(&value,1,0)); 
00B2:  BCF    03.0
00B3:  RRF    63,F
00B4:  MOVLW  00
00B5:  BTFSC  03.0
00B6:  MOVLW  01
00B7:  MOVWF  65
00B8:  MOVF   65,W
00B9:  MOVWF  66
*
00D4:  BCF    03.5
00D5:  INCF   64,F
00D6:  GOTO   0AE
....................    } 
00D7:  RETURN
.................... } 
.................... /* 
.................... This method will read a value from the DS18B20 following the read time slots 
.................... PARAMS: none 
.................... RETURNS: A bit from the DS1993 
.................... */ 
.................... int1 ds18b20_read_bit(void) 
.................... { 
....................    int1 value; 
....................    output_low(PIN_DS18B20_DATA);//drives output low for master 
00D8:  BSF    03.5
00D9:  BCF    06.5
00DA:  BCF    03.5
00DB:  BCF    06.5
....................    delay_us(2); 
00DC:  MOVLW  03
00DD:  MOVWF  77
00DE:  DECFSZ 77,F
00DF:  GOTO   0DE
....................    output_float(PIN_DS18B20_DATA);//sets MASTER to input mode to release pin 
00E0:  BSF    03.5
00E1:  BSF    06.5
....................    delay_us(8);//waits to read 
00E2:  MOVLW  0D
00E3:  MOVWF  77
00E4:  DECFSZ 77,F
00E5:  GOTO   0E4
....................    value=input(PIN_DS18B20_DATA); 
00E6:  BSF    06.5
00E7:  BCF    03.5
00E8:  BCF    65.0
00E9:  BTFSC  06.5
00EA:  BSF    65.0
....................    delay_us(120); 
00EB:  MOVLW  C7
00EC:  MOVWF  77
00ED:  DECFSZ 77,F
00EE:  GOTO   0ED
00EF:  GOTO   0F0
....................    return value; 
00F0:  MOVLW  00
00F1:  BTFSC  65.0
00F2:  MOVLW  01
00F3:  MOVWF  78
00F4:  RETURN
.................... } 
.................... /* 
.................... This method will call read() and update a byte bit by bit 
.................... PARAMS: none 
.................... RETURNS: A byte from the DS1993 
.................... */ 
.................... unsigned int8 ds18b20_read_byte() 
.................... { 
....................    unsigned int8 i, value; 
....................     
....................    for(i=0; i<8; i++) 
00F5:  CLRF   63
00F6:  MOVF   63,W
00F7:  SUBLW  07
00F8:  BTFSS  03.0
00F9:  GOTO   104
....................    { 
....................       shift_right(&value,1,ds18b20_read_bit()); 
00FA:  CALL   0D8
00FB:  MOVF   78,F
00FC:  BTFSS  03.2
00FD:  GOTO   100
00FE:  BCF    03.0
00FF:  GOTO   101
0100:  BSF    03.0
0101:  RRF    64,F
0102:  INCF   63,F
0103:  GOTO   0F6
....................    } 
....................    return value; 
0104:  MOVF   64,W
0105:  MOVWF  78
0106:  RETURN
.................... } 
....................  
.................... int1 ds18b20_start_conversion(void) 
.................... { 
....................    if (!ds18b20_start()) 
0107:  CALL   088
0108:  MOVF   78,F
0109:  BTFSS  03.2
010A:  GOTO   10E
....................       return(FALSE); 
010B:  MOVLW  00
010C:  MOVWF  78
010D:  GOTO   116
....................    ds18b20_write_byte(0xCC); 
010E:  MOVLW  CC
010F:  MOVWF  63
0110:  CALL   0AC
....................    ds18b20_write_byte(0x44); 
0111:  MOVLW  44
0112:  MOVWF  63
0113:  CALL   0AC
....................    return(TRUE); 
0114:  MOVLW  01
0115:  MOVWF  78
.................... } 
....................  
.................... int1 ds18b20_get_conversion(signed int16 *pTemp) 
.................... { 
....................    union  
....................    { 
....................       unsigned int8 b[2]; 
....................       signed int16 w; 
....................    } ret; 
....................     
....................    if (!ds18b20_start()) 
*
0124:  CALL   088
0125:  MOVF   78,F
0126:  BTFSS  03.2
0127:  GOTO   12B
....................       return(FALSE); 
0128:  MOVLW  00
0129:  MOVWF  78
012A:  GOTO   144
....................        
....................    ds18b20_write_byte(0xCC); 
012B:  MOVLW  CC
012C:  MOVWF  63
012D:  CALL   0AC
....................    ds18b20_write_byte(0xBE); 
012E:  MOVLW  BE
012F:  MOVWF  63
0130:  CALL   0AC
....................    ret.b[0] = ds18b20_read_byte(); 
0131:  CALL   0F5
0132:  MOVF   78,W
0133:  MOVWF  61
....................    ret.b[1] = ds18b20_read_byte(); 
0134:  CALL   0F5
0135:  MOVF   78,W
0136:  MOVWF  62
....................     
....................    *pTemp = ret.w; 
0137:  MOVF   5F,W
0138:  MOVWF  04
0139:  BCF    03.7
013A:  BTFSC  60.0
013B:  BSF    03.7
013C:  INCF   04,F
013D:  MOVF   62,W
013E:  MOVWF  00
013F:  DECF   04,F
0140:  MOVF   61,W
0141:  MOVWF  00
....................     
....................    return(TRUE); 
0142:  MOVLW  01
0143:  MOVWF  78
.................... } 
....................  
.................... int1 ds18b20_read(signed int16 *pTemp) 
.................... { 
....................    if (!ds18b20_start_conversion()) 
*
0116:  MOVF   78,F
0117:  BTFSS  03.2
0118:  GOTO   11C
....................       return(FALSE); 
0119:  MOVLW  00
011A:  MOVWF  78
011B:  GOTO   145
....................        
....................    while(!ds18b20_read_bit()); 
011C:  CALL   0D8
011D:  MOVF   78,F
011E:  BTFSC  03.2
011F:  GOTO   11C
....................        
....................    return(ds18b20_get_conversion(pTemp)); 
0120:  MOVF   5E,W
0121:  MOVWF  60
0122:  MOVF   5D,W
0123:  MOVWF  5F
*
0144:  MOVF   78,W
0145:  BSF    0A.3
0146:  BCF    0A.4
0147:  GOTO   04F (RETURN)
.................... } 
....................  
.................... /* 
.................... This method will initiate a temperature read (12 bit resolution) and convert  
.................... of the module by skipping the ROM of the module and reading from  
.................... the scratch pad 
.................... PARAMS: pTemp - where temperature is stored if valid read 
.................... RETURNS: TRUE if ds18b20 is on bus and acting properly 
.................... */ 
.................... /* 
.................... int1 ds18b20_read(signed int16 *pTemp) 
.................... { 
....................    unsigned int8 busy = 0; 
....................    union  
....................    { 
....................       unsigned int8 b[2]; 
....................       signed int16 w; 
....................    } ret; 
....................     
....................    if (!ds18b20_start()) 
....................       return(FALSE); 
....................    ds18b20_write_byte(0xCC); 
....................    ds18b20_write_byte(0x44); 
....................    while(busy==0) 
....................       busy=ds18b20_read_byte(); 
....................        
....................    if (!ds18b20_start()) 
....................       return(FALSE); 
....................    ds18b20_write_byte(0xCC); 
....................    ds18b20_write_byte(0xBE); 
....................    ret.b[0] = ds18b20_read_byte(); 
....................    ret.b[1] = ds18b20_read_byte(); 
....................     
....................    return(ret.w); 
.................... } 
.................... */ 
....................  
....................  
....................  
.................... signed int16 raw_temp; 
.................... float temp; 
.................... char buffer[2] = ""; 
*
0842:  CLRF   38
.................... int i = 0, s = 0; 
.................... int cont_zero = 0; 
.................... int tempo_on = 0; 
....................  
.................... #INT_EXT  
.................... void int_isr(){  
....................    cont_zero++; 
*
004F:  INCF   3C,F
....................      
....................    if (cont_zero > 10) { 
0050:  MOVF   3C,W
0051:  SUBLW  0A
0052:  BTFSC  03.0
0053:  GOTO   059
....................       cont_zero = 0; 
0054:  CLRF   3C
....................       output_low(PIN_B1); 
0055:  BSF    03.5
0056:  BCF    06.1
0057:  BCF    03.5
0058:  BCF    06.1
....................    } 
....................     
....................    if (cont_zero == tempo_on) 
0059:  MOVF   3D,W
005A:  SUBWF  3C,W
005B:  BTFSS  03.2
005C:  GOTO   061
....................       output_high(PIN_B1); 
005D:  BSF    03.5
005E:  BCF    06.1
005F:  BCF    03.5
0060:  BSF    06.1
0061:  BCF    0B.1
0062:  BCF    0A.3
0063:  BCF    0A.4
0064:  GOTO   02B
.................... } 
....................  
.................... /* 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
.................... { 
....................    //putc(getc()); 
....................    buffer[i] = getc(); 
....................    i++; 
....................    if (i == 1){ 
....................       i = 0; 
....................    } 
.................... } 
.................... */ 
....................  
.................... unsigned int setpoint = 35; 
....................  
.................... float Kp = 55.2; 
.................... float Ti = 6; 
.................... float T = 1.5; 
.................... float ultimo_erro = 0; 
.................... double PID = 0; 
.................... float erro_atual = 0; 
.................... float ultimo_controle = 0; 
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  FF
0804:  MOVWF  2B
0805:  BCF    2B.6
0806:  MOVF   2B,W
0807:  BSF    03.5
0808:  MOVWF  07
0809:  BCF    03.5
080A:  BSF    07.6
080B:  CLRF   3A
080C:  CLRF   3B
080D:  CLRF   3C
080E:  CLRF   3D
080F:  MOVLW  23
0810:  MOVWF  3E
0811:  MOVLW  CD
0812:  MOVWF  42
0813:  MOVLW  CC
0814:  MOVWF  41
0815:  MOVLW  5C
0816:  MOVWF  40
0817:  MOVLW  84
0818:  MOVWF  3F
0819:  CLRF   46
081A:  CLRF   45
081B:  MOVLW  40
081C:  MOVWF  44
081D:  MOVLW  81
081E:  MOVWF  43
081F:  CLRF   4A
0820:  CLRF   49
0821:  MOVLW  40
0822:  MOVWF  48
0823:  MOVLW  7F
0824:  MOVWF  47
0825:  CLRF   4E
0826:  CLRF   4D
0827:  CLRF   4C
0828:  CLRF   4B
0829:  CLRF   52
082A:  CLRF   51
082B:  CLRF   50
082C:  CLRF   4F
082D:  CLRF   56
082E:  CLRF   55
082F:  CLRF   54
0830:  CLRF   53
0831:  CLRF   5A
0832:  CLRF   59
0833:  CLRF   58
0834:  CLRF   57
0835:  CLRF   5C
0836:  CLRF   5B
0837:  BSF    03.5
0838:  BSF    1F.0
0839:  BSF    1F.1
083A:  BSF    1F.2
083B:  BCF    1F.3
083C:  MOVLW  07
083D:  MOVWF  1C
083E:  BCF    03.7
.................... { 
.................... EXT_INT_EDGE(L_TO_H); 
*
0843:  BSF    03.5
0844:  BSF    01.6
....................  
.................... enable_interrupts(INT_RDA); 
0845:  BSF    0C.5
.................... enable_interrupts(INT_EXT); 
0846:  BCF    03.5
0847:  BSF    0B.4
.................... enable_interrupts(GLOBAL); 
0848:  MOVLW  C0
0849:  IORWF  0B,F
....................   
....................  while(TRUE) { 
....................     if(ds18b20_read(&raw_temp)) { 
084A:  CLRF   5E
084B:  MOVLW  32
084C:  MOVWF  5D
084D:  BCF    0A.3
084E:  GOTO   107
084F:  BSF    0A.3
0850:  MOVF   78,F
0851:  BTFSC  03.2
0852:  GOTO   096
....................       temp = (float)raw_temp / 16;               // Convert temperature raw value into degree Celsius (temp in C = raw/16)             // Go to column 5 row 2 
0853:  MOVF   33,W
0854:  MOVWF  5E
0855:  MOVF   32,W
0856:  MOVWF  5D
0857:  BCF    0A.3
0858:  GOTO   148
0859:  BSF    0A.3
085A:  MOVF   7A,W
085B:  MOVWF  60
085C:  MOVF   79,W
085D:  MOVWF  5F
085E:  MOVF   78,W
085F:  MOVWF  5E
0860:  MOVF   77,W
0861:  MOVWF  5D
0862:  MOVF   60,W
0863:  MOVWF  68
0864:  MOVF   5F,W
0865:  MOVWF  67
0866:  MOVF   5E,W
0867:  MOVWF  66
0868:  MOVF   5D,W
0869:  MOVWF  65
086A:  CLRF   6C
086B:  CLRF   6B
086C:  CLRF   6A
086D:  MOVLW  83
086E:  MOVWF  69
086F:  BCF    0A.3
0870:  CALL   16F
0871:  BSF    0A.3
0872:  MOVF   7A,W
0873:  MOVWF  37
0874:  MOVF   79,W
0875:  MOVWF  36
0876:  MOVF   78,W
0877:  MOVWF  35
0878:  MOVF   77,W
0879:  MOVWF  34
....................       fprintf(PORT1,"Temp: %f", temp); 
087A:  MOVLW  65
087B:  BSF    03.6
087C:  MOVWF  0D
087D:  MOVLW  00
087E:  MOVWF  0F
087F:  BCF    03.0
0880:  MOVLW  06
0881:  BCF    03.6
0882:  MOVWF  5D
0883:  BCF    0A.3
0884:  CALL   25D
0885:  BSF    0A.3
0886:  MOVLW  89
0887:  MOVWF  04
0888:  MOVF   37,W
0889:  MOVWF  60
088A:  MOVF   36,W
088B:  MOVWF  5F
088C:  MOVF   35,W
088D:  MOVWF  5E
088E:  MOVF   34,W
088F:  MOVWF  5D
0890:  MOVLW  02
0891:  MOVWF  61
0892:  BCF    0A.3
0893:  CALL   378
0894:  BSF    0A.3
....................     } 
0895:  GOTO   09F
....................     else { 
....................       fprintf(PORT1," Error! "); 
0896:  MOVLW  6A
0897:  BSF    03.6
0898:  MOVWF  0D
0899:  MOVLW  00
089A:  MOVWF  0F
089B:  BCF    0A.3
089C:  BCF    03.6
089D:  GOTO   458
089E:  BSF    0A.3
....................     } 
....................     //setpoint = atoi(buffer); 
....................      
....................     erro_atual = setpoint - temp; 
089F:  CLRF   5E
08A0:  MOVF   3E,W
08A1:  MOVWF  5D
08A2:  BCF    0A.3
08A3:  GOTO   4B0
08A4:  BSF    0A.3
08A5:  BSF    03.1
08A6:  MOVF   7A,W
08A7:  MOVWF  64
08A8:  MOVF   79,W
08A9:  MOVWF  63
08AA:  MOVF   78,W
08AB:  MOVWF  62
08AC:  MOVF   77,W
08AD:  MOVWF  61
08AE:  MOVF   37,W
08AF:  MOVWF  68
08B0:  MOVF   36,W
08B1:  MOVWF  67
08B2:  MOVF   35,W
08B3:  MOVWF  66
08B4:  MOVF   34,W
08B5:  MOVWF  65
08B6:  BCF    0A.3
08B7:  CALL   4CF
08B8:  BSF    0A.3
08B9:  MOVF   7A,W
08BA:  MOVWF  56
08BB:  MOVF   79,W
08BC:  MOVWF  55
08BD:  MOVF   78,W
08BE:  MOVWF  54
08BF:  MOVF   77,W
08C0:  MOVWF  53
....................      
....................     PID = ultimo_controle+(Kp*((erro_atual-ultimo_erro)+(ultimo_erro*T/Ti))); 
08C1:  BSF    03.1
08C2:  MOVF   56,W
08C3:  MOVWF  64
08C4:  MOVF   55,W
08C5:  MOVWF  63
08C6:  MOVF   54,W
08C7:  MOVWF  62
08C8:  MOVF   53,W
08C9:  MOVWF  61
08CA:  MOVF   4E,W
08CB:  MOVWF  68
08CC:  MOVF   4D,W
08CD:  MOVWF  67
08CE:  MOVF   4C,W
08CF:  MOVWF  66
08D0:  MOVF   4B,W
08D1:  MOVWF  65
08D2:  BCF    0A.3
08D3:  CALL   4CF
08D4:  BSF    0A.3
08D5:  MOVF   7A,W
08D6:  MOVWF  60
08D7:  MOVF   79,W
08D8:  MOVWF  5F
08D9:  MOVF   78,W
08DA:  MOVWF  5E
08DB:  MOVF   77,W
08DC:  MOVWF  5D
08DD:  MOVF   4E,W
08DE:  MOVWF  6D
08DF:  MOVF   4D,W
08E0:  MOVWF  6C
08E1:  MOVF   4C,W
08E2:  MOVWF  6B
08E3:  MOVF   4B,W
08E4:  MOVWF  6A
08E5:  MOVF   4A,W
08E6:  MOVWF  71
08E7:  MOVF   49,W
08E8:  MOVWF  70
08E9:  MOVF   48,W
08EA:  MOVWF  6F
08EB:  MOVF   47,W
08EC:  MOVWF  6E
08ED:  BCF    0A.3
08EE:  CALL   2B4
08EF:  BSF    0A.3
08F0:  MOVF   7A,W
08F1:  MOVWF  64
08F2:  MOVF   79,W
08F3:  MOVWF  63
08F4:  MOVF   78,W
08F5:  MOVWF  62
08F6:  MOVF   77,W
08F7:  MOVWF  61
08F8:  MOVF   64,W
08F9:  MOVWF  68
08FA:  MOVF   63,W
08FB:  MOVWF  67
08FC:  MOVF   62,W
08FD:  MOVWF  66
08FE:  MOVF   61,W
08FF:  MOVWF  65
0900:  MOVF   46,W
0901:  MOVWF  6C
0902:  MOVF   45,W
0903:  MOVWF  6B
0904:  MOVF   44,W
0905:  MOVWF  6A
0906:  MOVF   43,W
0907:  MOVWF  69
0908:  BCF    0A.3
0909:  CALL   16F
090A:  BSF    0A.3
090B:  BCF    03.1
090C:  MOVF   60,W
090D:  MOVWF  64
090E:  MOVF   5F,W
090F:  MOVWF  63
0910:  MOVF   5E,W
0911:  MOVWF  62
0912:  MOVF   5D,W
0913:  MOVWF  61
0914:  MOVF   7A,W
0915:  MOVWF  68
0916:  MOVF   79,W
0917:  MOVWF  67
0918:  MOVF   78,W
0919:  MOVWF  66
091A:  MOVF   77,W
091B:  MOVWF  65
091C:  BCF    0A.3
091D:  CALL   4CF
091E:  BSF    0A.3
091F:  MOVF   42,W
0920:  MOVWF  6D
0921:  MOVF   41,W
0922:  MOVWF  6C
0923:  MOVF   40,W
0924:  MOVWF  6B
0925:  MOVF   3F,W
0926:  MOVWF  6A
0927:  MOVF   7A,W
0928:  MOVWF  71
0929:  MOVF   79,W
092A:  MOVWF  70
092B:  MOVF   78,W
092C:  MOVWF  6F
092D:  MOVF   77,W
092E:  MOVWF  6E
092F:  BCF    0A.3
0930:  CALL   2B4
0931:  BSF    0A.3
0932:  BCF    03.1
0933:  MOVF   5A,W
0934:  MOVWF  64
0935:  MOVF   59,W
0936:  MOVWF  63
0937:  MOVF   58,W
0938:  MOVWF  62
0939:  MOVF   57,W
093A:  MOVWF  61
093B:  MOVF   7A,W
093C:  MOVWF  68
093D:  MOVF   79,W
093E:  MOVWF  67
093F:  MOVF   78,W
0940:  MOVWF  66
0941:  MOVF   77,W
0942:  MOVWF  65
0943:  BCF    0A.3
0944:  CALL   4CF
0945:  BSF    0A.3
0946:  MOVF   7A,W
0947:  MOVWF  52
0948:  MOVF   79,W
0949:  MOVWF  51
094A:  MOVF   78,W
094B:  MOVWF  50
094C:  MOVF   77,W
094D:  MOVWF  4F
....................      
....................     /* 
....................     if (PID > 100) { 
....................       tempo_on = 0; 
....................     } 
....................  
....................     else if (PID < -100) { 
....................       tempo_on = 10; 
....................     } 
....................       
....................     else 
....................       tempo_on = 10 - (PID/10); 
....................       */ 
....................        
....................       tempo_on = 4; 
094E:  MOVLW  04
094F:  MOVWF  3D
....................        
....................       ultimo_erro = erro_atual; 
0950:  MOVF   56,W
0951:  MOVWF  4E
0952:  MOVF   55,W
0953:  MOVWF  4D
0954:  MOVF   54,W
0955:  MOVWF  4C
0956:  MOVF   53,W
0957:  MOVWF  4B
....................       ultimo_controle = PID; 
0958:  MOVF   52,W
0959:  MOVWF  5A
095A:  MOVF   51,W
095B:  MOVWF  59
095C:  MOVF   50,W
095D:  MOVWF  58
095E:  MOVF   4F,W
095F:  MOVWF  57
....................        
....................       //fprintf(PORT1,"%f ", ultimo_erro); 
....................        
....................       //fprintf(PORT1,"S%uE ", tempo_on); 
....................        
....................       fprintf(PORT1,"PID: %f ", PID); 
0960:  MOVLW  6F
0961:  BSF    03.6
0962:  MOVWF  0D
0963:  MOVLW  00
0964:  MOVWF  0F
0965:  BCF    03.0
0966:  MOVLW  05
0967:  BCF    03.6
0968:  MOVWF  5D
0969:  BCF    0A.3
096A:  CALL   25D
096B:  BSF    0A.3
096C:  MOVLW  89
096D:  MOVWF  04
096E:  MOVF   52,W
096F:  MOVWF  60
0970:  MOVF   51,W
0971:  MOVWF  5F
0972:  MOVF   50,W
0973:  MOVWF  5E
0974:  MOVF   4F,W
0975:  MOVWF  5D
0976:  MOVLW  02
0977:  MOVWF  61
0978:  BCF    0A.3
0979:  CALL   378
097A:  BSF    0A.3
097B:  MOVLW  20
097C:  MOVWF  6A
097D:  BCF    0A.3
097E:  CALL   239
097F:  BSF    0A.3
....................        
....................       fprintf(PORT1,"set: %i\n", setpoint); 
0980:  MOVLW  74
0981:  BSF    03.6
0982:  MOVWF  0D
0983:  MOVLW  00
0984:  MOVWF  0F
0985:  BCF    03.0
0986:  MOVLW  05
0987:  BCF    03.6
0988:  MOVWF  5D
0989:  BCF    0A.3
098A:  CALL   25D
098B:  BSF    0A.3
098C:  MOVF   3E,W
098D:  MOVWF  5D
098E:  MOVLW  18
098F:  MOVWF  5E
0990:  BCF    0A.3
0991:  GOTO   625
0992:  BSF    0A.3
0993:  MOVLW  0A
0994:  MOVWF  6A
0995:  BCF    0A.3
0996:  CALL   239
0997:  BSF    0A.3
....................        
....................        
....................       delay_ms(2000); 
0998:  MOVLW  08
0999:  MOVWF  5D
099A:  MOVLW  FA
099B:  MOVWF  5E
099C:  BCF    0A.3
099D:  GOTO   67E
099E:  BSF    0A.3
099F:  DECFSZ 5D,F
09A0:  GOTO   19A
09A1:  GOTO   04A
....................  
....................   } 
.................... } 
....................  
09A2:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
